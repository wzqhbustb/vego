# Vego 路线图

## 概述

| 阶段 | 目标 | 时间线 | 关键交付物 |
|------|------|--------|-----------|
| Phase 0 | 统一 API 与基础 | 1-2 周 | 用户友好的 API、基础集成测试 |
| **Phase 1** | 存储引擎加固 | 4-6 周 | 行索引、块缓存、Get() O(n) 修复、异步 I/O |
| Phase 2 | MVP（最小可行产品） | 6-8 周 | CRUD 操作、基础查询、性能基线 |
| Phase 3 | Beta 版 | 8-10 周 | CMO、投影下推、Zone Map |
| Phase 4 | V1.0 性能版 | 10-12 周 | MiniBlock、预取、SIMD |
| Phase 5 | V1.5 极致版 | 12-16 周 | io_uring、向量化执行 |
| Phase 6 | V2.0 企业版 | 20-24 周 | WAL、MVCC、索引、分区 |

**当前重点**：Phase 0 - 构建统一的、用户友好的 API 层，无缝集成 HNSW 向量搜索与列式存储。

> **Phase 0 范围调整说明**：若干非关键任务（备份/恢复、高级可观测性、结构化错误）已推迟至 Phase 6，以优先在 Phase 1 修复关键的 Get() O(n) 性能问题。详见 Phase 6 "第五层" 了解推迟的任务。

---

## Phase 0: 统一 API 与基础 ⭐ 当前优先

### 目标
创建统一、直观的 API，将 HNSW 向量搜索与列式存储相结合，让用户无需深入了解底层组件即可使用 Vego。

### 愿景
```go
// Vego API 应该如此简单：
db, _ := vego.Open("./mydb", vego.WithDimension(768))
coll, _ := db.Collection("documents")

// 插入自动生成的嵌入向量
coll.Insert(&vego.Document{
    ID:       vego.DocumentID(),
    Vector:   embedding,  // 你的 768 维向量
    Metadata: map[string]any{"title": "Hello", "author": "Alice"},
})

// 带元数据过滤的向量搜索
results, _ := coll.Search(queryVector, 10,
    vego.WithFilter(vego.MetadataFilter{
        Field: "author", Operator: "eq", Value: "Alice",
    }),
)
```

### 关键任务

#### 1. 统一的 DB/Collection API ✅
- [x] `vego.Open()` - 打开或创建数据库
- [x] `db.Collection()` - 获取或创建集合
- [x] `db.DropCollection()` - 删除集合
- [x] `db.Collections()` - 列出所有集合
- [x] `db.Close()` - 优雅关闭

#### 2. 以文档为中心的 Collection API ✅
- [x] `coll.Insert(doc)` - 插入单个文档
- [x] `coll.InsertBatch(docs)` - 批量插入
- [x] `coll.Get(id)` - 根据 ID 检索
- [x] `coll.Delete(id)` - 删除文档
- [x] `coll.Update(doc)` - 更新文档
- [x] `coll.Upsert(doc)` - 插入或更新

#### 3. 向量搜索 API ✅
- [x] `coll.Search(query, k, opts...)` - 向量相似度搜索
- [x] `coll.SearchWithFilter(query, k, filter)` - 带元数据过滤的搜索
- [x] `coll.SearchBatch(queries, k, opts...)` - 批量搜索

#### 4. 配置 API ✅
- [x] `vego.WithDimension(d)` - 设置向量维度
- [x] `vego.WithAdaptive(bool)` - 启用自适应调优
- [x] `vego.WithExpectedSize(n)` - 预期数据集大小
- [x] `vego.WithDistanceFunc(fn)` - 距离度量（L2/余弦/内积）
- [x] `vego.WithM(m)` - HNSW M 参数
- [x] `vego.WithEfConstruction(ef)` - HNSW 构建质量

#### 5. 持久化 API 🔄
- [x] `coll.Save()` - 将集合持久化到磁盘
- [x] `coll.Close()` - 关闭时自动保存
- [x] `coll.Load()` - 从磁盘重新加载（初始化时验证）
- [~] `db.Backup(path)` - 完整数据库备份（推迟至 Phase 6）
- [~] `db.Restore(path)` - 从备份恢复（推迟至 Phase 6）

#### 6. 性能与可观测性 📊
- [ ] `coll.Stats()` - 集合统计信息（修复孤儿节点计数）
- [~] `db.Stats()` - 数据库级统计（推迟至 Phase 6）
- [~] 查询延迟指标（推迟至 Phase 6）
- [~] 索引构建进度回调（推迟至 Phase 6）

#### 7. 错误处理与可靠性 🔧
- [~] 结构化错误类型（推迟至 Phase 6）
- [~] 批量操作中的部分失败处理（推迟至 Phase 6）
- [~] 瞬态故障自动重试（推迟至 Phase 6）
- [x] 加载时损坏检测（基础验证已存在）

### 完成标准
- [x] 用户无需直接接触 `index` 或 `storage` 包即可执行所有 CRUD 操作
- [ ] 示例展示真实用例（RAG、语义搜索、推荐系统）
- [x] API 文档及使用模式
- [~] vego 包单元测试覆盖率 > 70%（目标移至 Phase 1）
- [ ] 完整工作流的集成测试（基础覆盖）

### API 设计原则

1. **简洁优先**：常用操作应该是一行代码
2. **合理默认**：自适应配置开箱即用
3. **渐进式披露**：初学者简单，专家强大
4. **一致性**：DB、Collection 和 Query API 采用相似模式
5. **快速失败**：在 API 边界验证，错误信息清晰

---

## Phase 1: 存储引擎加固

### 目标
巩固存储基础，建立基准测试，确保后续开发无需返工。

### 关键任务

#### 第 1-2 周：文件格式基础
- **文件版本管理**：向 Header/Footer 添加版本字段，兼容性检查框架
- **格式演进策略**：设计未来模式变更的前向/后向兼容性

#### 第 2-4 周：内存索引与缓存（关键路径）
- **行索引实现**：idHash → rowIndex 映射，修复 Get() O(n) 复杂度
  - 启动时从 vectors.lance 构建（内存中，<100万文档无需持久化）
  - O(1) 文档检索查找
- **文档 LRU 缓存**：热文档缓存，用于频繁访问的向量
  - 缓存搜索结果以避免重复磁盘读取
  - 可配置容量（默认：1万文档）
- **GetBatch 优化**：批量加载以减少搜索结果的 I/O 往返

#### 第 4-6 周：存储引擎加固
- **块缓存实现**：64KB 块、LRU 淘汰、线程安全的页面缓存
- **写入器异步优化**：并行编码，保证顺序写入
- **性能基线建立**：全面的基准测试套件，验证 O(1) Get()
- **端到端集成测试**：从写入到读取的完整路径覆盖，含缓存验证

#### 第 5-6 周：存储基础（非阻塞）
- **Delta 编码实现**：时间序列数据的变长整数编码
- **错误分类系统**：`lance/errors` 包，结构化错误处理
- **页面级统计（Min/Max）**：Phase 3 Zone Map 的基础
- **可空编码统一处理**：目前仅 Zstd 支持 null；统一所有编码器的 null 处理

### 步骤
1. 错误分类系统 ✅
2. 端到端集成测试 ✅
3. 性能基线测试 ✅
4. 性能优化：
   - 索引构建性能（HNSW）
   - 查询性能（HNSW）
5. 文件版本管理机制
6. 页面级统计框架
7. Delta 编码框架
8. 可空统一处理（最复杂）- 需要修改所有编码器

### 完成标准
- [ ] 文件版本管理：能够检测和处理格式版本不匹配
- [ ] Get() 操作平均 O(1)（通过行索引 + 缓存）
- [ ] Search(k=10) 处理 10万文档在 < 100ms 内完成（对比当前 10+ 秒）
- [ ] 所有编码器通过往返测试（编码 → 解码 → 数据完整性）
- [ ] `go test -race` 无竞态条件
- [ ] 基准测试目标：写入 100MB 向量数据 < 5秒，读取 < 2秒
- [ ] 代码测试覆盖率 > 60%

### 依赖关系
- 第 1-2 周（文件版本）必须在任何磁盘格式变更前完成
- 第 2-4 周（行索引 + 缓存）可在文件版本稳定后开始
- 第 4-6 周（块缓存）依赖行索引进行缓存键管理
- 第 5-6 周任务为非阻塞，可并行进行

---

## Phase 2: MVP（最小可行产品）

### 目标
使系统能够处理真实世界的数据，具备基础 CRUD 和查询能力。

### 关键任务

#### HNSW 索引加固
- **真正的删除支持**：从 HNSW 索引的所有层移除节点，重新连接邻居以保持图连通性
- **墓碑机制**：标记删除节点用于延迟清理或立即移除
- **孤儿预防**：更新操作正确处理旧节点（重用或删除）
- **索引压缩**：后台重建以移除删除节点并优化图结构

#### 存储引擎增强
- **累积缓冲区**：避免小页面（< 4KB）
- **基础监控**：I/O 计数、缓存命中率、编码延迟
- **请求合并**：合并相邻 I/O 请求
- **表抽象层**：用户的高级 API
- **Manifest 基础版本**：文件元数据管理（Phase 5 MVCC 的基础）
- **列裁剪（基础）**：仅读取所需列

#### 性能优化
  - 异步 I/O 内存开销
  - Page Writer 支持异步 IO
  - 多读取器并发退化（当前：4x 并发 = 4x  slowdown！）
    ```
    并发 1:  2.3 ms
    并发 4:  9.2 ms  (4x 退化！)
    并发 16: 38 ms   (16x 退化！)
    ```

### 完成标准
- [ ] 单文件 1GB 向量数据读写不 OOM
- [ ] 重复查询性能提升 5x+（缓存命中）
- [ ] 写入 100万向量（768维）< 30秒
- [ ] 提供高级 API：`lance.Open()` / `lance.Write()` / `lance.Read()`
- [ ] 删除操作真正从 HNSW 索引移除节点（无索引膨胀）
- [ ] 更新操作不创建孤儿节点（或重用旧节点）
- [ ] 索引压缩在大批量删除后减少大小（>30% 空间回收）

---

## Phase 3: Beta（生产就绪）

### 目标
生产级的可靠性、可观测性和查询优化，确保部署信心。

### 关键任务
- **CMO（列元数据偏移）表**：O(1) 列查找，支持 1000+ 列
- **投影下推**：仅读取所需列
- **页面跳过（Zone Map）**：Min/Max 统计跳过无关页面
- **错误恢复**：文件损坏检测、部分读取
- **全面监控**：Prometheus 指标导出
- **配置系统**：可调缓存大小、压缩级别
- **流式读取**：大文件无需完全加载到内存
- **并行列读取**：多列并行加载（3-4x 性能提升）

### 完成标准
- [ ] 1000 列文件打开时间 < 100ms（对比当前 O(n) 扫描）
- [ ] 单列查询 I/O 减少 90%
- [ ] 文件损坏定位到特定页面，支持部分恢复
- [ ] Prometheus 导出器，关键指标可观测

---

## Phase 4: V1.0（性能版）

### 目标
达到接近 Rust Lance 80% 的性能。

### 关键任务
- **MiniBlock 架构重构**：页面内部块结构
- **智能预取**：顺序预取 + 步进预取（列式）
- **字符串压缩优化**：Snappy 作为 FSST 替代方案（务实选择）
- **编码器 SIMD 优化**：BitPacking 和其他关键路径
- **内存池优化**：减少 GC 压力，细粒度对象池
- **自适应压缩级别**：基于数据特征自动选择压缩
- **批处理解码优化**：每次操作处理多个值

### 完成标准
- [ ] 压缩比：整数 > 70%，字符串 > 60%（Snappy）
- [ ] 顺序扫描性能提升 3x（对比 MVP）
- [ ] 解码开销 < 原始读取成本的 5%
- [ ] 单文件支持 100GB+ 数据集

---

## Phase 5: V1.5（极致版）

### 目标
超越竞争对手，成为最快的 Go 列式存储。

### 关键任务
- **io_uring 支持（仅限 Linux）**：极致 I/O 性能
- **向量化执行**：基于 Arrow 的 SIMD 计算
- **FSST 最终实现**：时间允许的话，纯 Go 实现或 CGO 绑定
- **自适应编码优化**：基于 ML 的最优编码选择

### 完成标准
- [ ] TPC-H 查询性能接近 DuckDB 的 50%
- [ ] 向量搜索性能达到 Milvus/Lance 的 80%

---

## Phase 6: V2.0（企业版）- 长期

### 目标
从"存储引擎"演进为"数据库系统"。

### 关键任务（按优先级）

#### 第一层：数据安全（必需）
- **WAL（预写日志）**：崩溃恢复
- **校验和**：每页 CRC、每文件完整性验证
- **备份/快照**：时间点恢复

#### 第二层：事务 MVCC
- **快照隔离**：读取历史版本
- **乐观并发控制**：写写冲突检测
- **多版本并发控制**
- **范围外**：两阶段提交、分布式事务

#### 第三层：索引系统
- **BTree 索引**：标量字段
- **Bloom Filter**：存在性查询
- **向量索引 HNSW**：外部集成（已实现）

#### 第四层：分布式
- **数据分区**
- **分区裁剪**
- **并行查询执行**

#### 第四层：查询引擎（待定规划）
- **表达式系统（基础）**：简单过滤
- **行级过滤**：在 RecordBatch 上执行过滤器

#### 第五层：Phase 0 推迟任务（从 Phase 0 移至此处）
以下任务有意从 Phase 0 推迟，以专注于核心性能：

- **数据库备份/恢复**：`db.Backup(path)`、`db.Restore(path)` 用于灾难恢复
- **高级可观测性**：`db.Stats()`、查询延迟指标、索引构建进度回调
- **增强错误处理**：结构化错误类型、批量操作中的部分失败处理、瞬态故障自动重试
- **测试覆盖**：vego 包单元测试覆盖率 > 70%

### 完成标准
- [ ] 崩溃后 100% 数据恢复
- [ ] 支持并发读写（快照读）
- [ ] 标量查询性能提升 100x（BTree）

---

## 架构决策记录（ADR）

### ADR 1: API 优先设计
**背景**：用户无需理解 HNSW 或 Lance 内部即可使用 Vego  
**决策**：构建统一的 `vego` 包作为主要 API，`index` 和 `storage` 作为内部实现  
**影响**：更简单的用户体验、更易维护的代码库、更易测试

### ADR 2: 以文档为中心的模型
**背景**：向量数据库自然适合文档导向模式  
**决策**：主要 API 使用 Document（ID + 向量 + 元数据），而非原始向量  
**影响**：对用户更直观、支持元数据过滤、符合用例

### ADR 3: 放弃 FSST，采用 Snappy
**背景**：FSST 实现复杂度需要 2-3 周专门投入  
**决策**：v1.0 使用 Snappy，v1.5+ 重新评估 FSST  
**影响**：字符串压缩比从 70% 降至 60%，节省开发时间 2 周

### ADR 4: MiniBlock 必须支持向后兼容
**背景**：文件格式一旦发布，需要长期维护  
**决策**：读取器支持新旧格式；写入器默认使用新格式  
**影响**：读取器代码复杂度增加，但避免痛苦的用户数据迁移

### ADR 5: 事务采用乐观并发控制
**背景**：Lance 主要用于分析，写写冲突罕见  
**决策**：放弃悲观锁，采用 MVCC + 乐观冲突检测  
**影响**：极高的读性能；写冲突返回错误由应用层重试

### ADR 6: 优先块缓存而非 OS 页缓存
**背景**：Go 对 OS 页缓存控制较弱  
**决策**：用户空间块缓存用于精确的内存和预取控制  
**影响**：内存使用略高，但性能更可预测

### ADR 7: 异步 I/O 策略调整
**背景**：当前 AsyncIO 实现性能不如同步 I/O  
**决策**：Phase 1 默认使用同步 I/O，异步 I/O 作为实验性功能  
**影响**：API 必须支持两种模式；用户可显式选择

### ADR 8: 压缩策略
**背景**：小文件压缩开销 > 收益  
**决策**：< 1MB 文件使用 Plain 编码，> 1MB 使用 ZSTD  
**影响**：压缩比略低，速度显著提升

---

## 额外待办

### 测试
- [ ] 覆盖更多测试用例
- [ ] 编码/解码的模糊测试
- [ ] 容错混沌测试
- [ ] CI 中的性能回归测试

### 文档
- [x] API 参考文档（examples/README.md）
- [ ] 性能调优指南
- [ ] 部署和运维指南
- [ ] 从其他格式迁移指南（Parquet 等）

### 工具
- [ ] Lance 文件检查器/转储器
- [ ] 格式转换工具
- [ ] 基准对比工具
- [ ] 可视化分析器集成

---

## 为路线图做贡献

本路线图是活的文档。我们欢迎：
- 不同环境的性能基准测试结果
- 优先级调整建议
- 新功能或 ADR 提案
- 特定阶段可行性反馈

请在提交 PR 前开 issue 讨论任何路线图变更。
